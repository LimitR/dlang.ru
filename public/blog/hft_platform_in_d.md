# Я написал высокочастотную торговую платформу на D

**Оригинал (англ.)**: [The D Blog/I Wrote a High-Frequency Trading Platform In D](https://dlang.org/blog/2021/12/11/i-wrote-a-high-frequency-trading-platform-in-d/)

**Автор**: [Georges Toutoungis](https://dlang.org/blog/author/georgetoutoungis/)

**Перевод**: DarkRIDDeR (12.12.2021)

---

<img style="float: right; margin-left: 1em" src="https://i1.wp.com/dlang.org/blog/wp-content/uploads/2019/03/brain02.png?resize=200%2C200&ssl=1">

Я использовал язык программирования D для реализации платформы высокочастотной торговли (HFT). Я был вполне удовлетворен полученным опытом и решил поделиться тем, как я пришел к этому. Это был извилистый путь.

В 2008 году я наткнулся на книгу на Amazon под названием Learn to Tango with D. Это вызвало у меня любопытство, и я решил изучить D подробнее. Это привело меня к Digital Mars и Уолтеру Брайту. Впервые я услышал об Уолтере, когда узнал о Zortech C++, первом собственном компиляторе C++. Его работа оказала огромное влияние на мой опыт изучения C++. Поэтому я сразу же заинтересовался языком только потому, что он был его, и был рад узнать, что он работает с Андреем Александреску над второй версией. Тем не менее, я решил подождать, пока они не продвинутся дальше в разработке новой версии, прежде чем приступать к изучению.

В 2010 году я купил книгу Андрея "Язык программирования D", как только она была опубликована, и начал читать. В то время я работал в BNP Paribas, используя C++ для оптимизации своей HFT-платформы, поэтому в моих мыслях преобладала высокая производительность. Когда я увидел, что классы в D являются ссылочными типами, а функции по умолчанию виртуальные, я был разочарован. Я не понимал, как это может быть полезно для программирования с низкой задержкой. В то время я был слишком занят работой, чтобы продолжить изучение, поэтому отложил книгу и язык в сторону.

В 2014 году я начал готовиться к новому приключению. В рамках этого я начал работу над фреймворком обработчика фидов на C++, используя свою собственную давно поддерживаемую библиотеку C++ низкоуровневых компонентов, полезных в высокопроизводительных приложениях с низкой задержкой. Книга Андрея снова попалась мне на глаза, и я решил взглянуть на нее еще раз.

На этот раз я дочитал книгу до конца и понял, что мое первой впечатление было ошибочным. Я обнаружил, что мне понравились возможности метапрограммирования в D и его поддержка программирования в функциональном стиле. К концу книги я был готов попробовать D.

Я начал с переноса своей библиотеки C++ и обработчика фидов на D. Это было несложно. В своем коде на C++ я использую очень мало наследований, предпочитая композиции и конкретные классы. Я нашел свою работу достаточно продуктивной со структурами, шаблонами и миксинами языка D. При этом я внимательно следил за показателями производительности. Когда оказалось, что D дает такую же производительность, как и мой код на C++, я полностью увлёкся им. Я обнаружил, что D намного элегантнее, чище, читабельнее и проще в поддержке. Я перешел на D и никогда не оглядывался назад.

Моей целью было разработать  с использованием D полную систему HFT, включающую различные подсистемы:

- Feed-Handler Framework: получает рыночные данные от бирж; создает книги для всех ценных бумаг; публикует обновления для других подсистем.
- Strategies Framework: получает обновления рыночных данных от обработчиков фидов; облегчает связь с системой управления заказами; позволяет подключать к ней стратегии, принимающие решения о торговле акциями.
- System Order Management System: взаимодействует с биржей и системой стратегий; поддерживает базу данных ордеров.
- Signal Generator: получает обновления рыночных данных от обработчиков фидов; генерирует различные сигналы в виде значений индикаторов, прогнозов цен на акции и т.д.; посылает различные сигналы стратегиям.

В конце концов, я нашел новую структуру данных и лучший дизайн для моего фреймворка feed-handler. Я разработал новую версию полностью на D. Эта реализация в значительной степени использует шаблоны. Мне нравится синтаксис шаблонов в D, и в целом я нахожу сообщения об ошибках более понятными, чем сложные сообщения об ошибках, к которым я привык в C++. Мне потребовалось перейти к ассемблеру для реализации некоторых специфических инструкций x86, и это было легко сделать на D.

Позже мне понадобилось поработать с конфигурационными файлами. Я предпочитаю писать свои конфигурационные файлы на Lua, легком скриптовом языке, который легко интегрировать в программу в качестве расширения через его C API. Для этого я нашел привязку D Lua под названием DerelictLua. Используя, опять же, средства метапрограммирования D, я разработал очень простой и практичный способ взаимодействия с Lua поверх DerelictLua. ( Примечание редактора: с тех пор поддержка DerelictLua была прекращена; новые проекты должны использовать его преемника, bindbc-lua ).

Обработчик фидов на рынке Bats (биржевая площадка для высокочастотной торговли) работает используя одновременно 31 канал, поэтому эффективнее использовать многопоточность. Для этого я решил не использовать средства многопоточности, предоставляемые Phobos. Я посчитал, что мне нужен больший контроль в такой среде с низкой задержкой, особенно возможность привязывать потоки к определенному ядру. Я предпочел использовать библиотеку pthreads и ее функцию affinity. Совместимость D с C ABI сделала это простым делом.

Моя система работает на FreeBSD. Для межсетевого взаимодействия я использую очереди и сокеты ядра. Та же функциональность доступна на macOS, моей любимой платформе для разработки. D не встал на моем пути при использовании этих API ни на macOS, ни на FreeBSD. Это было так же просто, как использование очередей ядра из C.

Несколько заметок о проблемах и ограничениях:

- Я столкнулся с одной ошибкой компилятора. Я нашел обходной путь, так что это не было препятствием. Я смог воспроизвести ее с помощью нескольких строк кода и связался с сообществом D. Они решили проблему и исправили ее в более поздней версии компилятора.
- Я не использовал сборщик мусора в D. Однако это не является проблемой D или его GC. В такой системе с низкой задержкой, как эта, даже использование malloc и free может быть дорогостоящим, поэтому я не собирался рисковать недетерминированной системой с непредсказуемой задержкой. Вместо этого я использовал свою библиотеку для обработки выделения/деаллокации посредством списоков освобождения (free list) с предварительным выделением памяти. Как следствие, я также решил ни для чего не использовать стандартную библиотеку D.
- Мне нужно было работать со строками ASCII фиксированного размера, которые не имеют NUL-терминала, а вместо него в конце добавляются пробелы. Без стандартной библиотеки мне было проще работать с ними в стиле C с помощью указателей.

Я был единственным разработчиком в этом проекте, но успешно завершил его за относительно короткий срок. Большая заслуга D и его производительности, читабельности и легкости модификаций.







